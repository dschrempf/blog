<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codings on Concept → IO ()</title>
    <link>https://dschrempf.github.io/coding/</link>
    <description>Recent content in Codings on Concept → IO ()</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Feb 2018 00:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://dschrempf.github.io/coding/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Markov chains in Haskell</title>
      <link>https://dschrempf.github.io/coding/2018-02-10-markov-chains-in-haskell/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0100</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2018-02-10-markov-chains-in-haskell/</guid>
      <description>I have been working on Markov chains for quite a while now and wanted to assess how Haskell can deal with simulating a simple, discrete chain.
Many sources can be found online. The code presented here is partly taken from a question on stackoverflow. However, I was unsatisfied with the nomenclature and parts of the code. So I refactored most of it. Also, there is a Haskell library markov-chain, which I am unsatisfied with because of code readability (it&amp;rsquo;s pretty abstruse).</description>
    </item>
    
    <item>
      <title>Happy folding around monads in Haskell</title>
      <link>https://dschrempf.github.io/coding/2017-07-20-folding-around-monads-in-haskell/</link>
      <pubDate>Thu, 20 Jul 2017 00:00:00 +0200</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2017-07-20-folding-around-monads-in-haskell/</guid>
      <description>Folds are complicated themselves, but monadic folds always have blown my mind. In what follows, I try to dissect foldlM for a specific example.
Monadic folds can be used to perform a series of actions that depend on the previous output. The following function produces an action b from a value a also taking into account the output of the previous action b.
f :: (b -&amp;gt; a -&amp;gt; m b)  And here the definition of foldlM (which is the same as foldM).</description>
    </item>
    
    <item>
      <title>A simulator for continuous-time Markov chains</title>
      <link>https://dschrempf.github.io/coding/2016-04-09-continuous-time-markov-chain/</link>
      <pubDate>Sat, 09 Apr 2016 00:00:00 +0200</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2016-04-09-continuous-time-markov-chain/</guid>
      <description>[2016-04-09 Sat]  I extended my set of C++ programs to include a simulator for generic continuous-time Markov chains. I.e., any transition rate matrix can be used.
If you are interested, just get the GitHub repository and compile the whole set of programs with make all. Documentation can be found in the doc/ folder (check the CTMC class).
There is a sample program src/moran_model_boundary_mutation, that runs the Moran model with boundary mutation (De Maio, N.</description>
    </item>
    
    <item>
      <title>Population genetics C&#43;&#43; programs</title>
      <link>https://dschrempf.github.io/coding/2015-03-26-popgen-cpp-programs/</link>
      <pubDate>Thu, 26 Mar 2015 00:00:00 +0100</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2015-03-26-popgen-cpp-programs/</guid>
      <description>I maintain a Github repository that contains a bunch of very basic C++ programs that use Markov chains and other types of simulations to infer basic statistical parameters. The applications mainly focus on Population Genetics problems, although this is not always the case. At the moment, the list of programs is:
 bookshelf.cpp Bookshelf Markov chain brownian_motion_mcmc.cpp Simulate standard Brownian motion (Wiener process) coin_toss_mcmc.cpp Run a coin toss MCMC simulation cube_mcmc.</description>
    </item>
    
    <item>
      <title>A simple MCMC simulation</title>
      <link>https://dschrempf.github.io/coding/2015-01-15-mcmc-coin-toss/</link>
      <pubDate>Thu, 15 Jan 2015 00:00:00 +0100</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2015-01-15-mcmc-coin-toss/</guid>
      <description>Suppose we observe 58 heads out of 100 coin tosses. Now, we want to know the probability of tossing a head \(\theta\). A maximum likelihood guess would be \(\theta = 0.58\) because then, the probability of observing 58 heads
\begin{align} P(58 \mathrm{ heads}) = {100 \choose 58} (0.58)^{58} (0.42)^{42} \end{align}
is greatest (an example of the binomial distribution).
However, we could also use a Bayesian approach to calculate the posterior distribution of the probability \(\theta\) (i.</description>
    </item>
    
    <item>
      <title>Easy pretty print in Haskell</title>
      <link>https://dschrempf.github.io/coding/2014-12-23-haskell-pretty-print/</link>
      <pubDate>Tue, 23 Dec 2014 00:00:00 +0100</pubDate>
      
      <guid>https://dschrempf.github.io/coding/2014-12-23-haskell-pretty-print/</guid>
      <description>I repeatedly struggle with GHCi when I want to print lists and maps and actually look at them and analyze them. Today I came accross pretty-show, a haskell package that allows pretty printing of all objects that are instances of the type class Show.
The usage is very straight forward:
import qualified Text.Show.Pretty as Pr  This provides Pr.ppShow which can be used in GHCi (or other interpreters):
putStrLn $ Pr.</description>
    </item>
    
  </channel>
</rss>